[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "인덱스",
    "section": "",
    "text": "이 페이지는 인덱스다."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index_proj.html",
    "href": "index_proj.html",
    "title": "희희희~",
    "section": "",
    "text": "하수관로 수위센서 활용 위험지역 탐지\n\n\n\n\n\n\n\nPYTHON\n\n\n\n\n제1회 강남구 공공데이터 활용 공모전\n\n\n\n\n\n\nApr 29, 2024\n\n\n나무껍질가이즈\n\n\n\n\n\n\n  \n\n\n\n\n군집화\n\n\n\n\n\n\n\nPython\n\n\nipynb\n\n\n\n\n하수구 위치, 표고(지형) 데이터를 사용한 군집화\n\n\n\n\n\n\nApr 24, 2024\n\n\nSungil_Park\n\n\n\n\n\n\n  \n\n\n\n\nproj_2\n\n\n\n\n\n\n\nPython\n\n\nipynb\n\n\n\n\n단단한 나무껍질\n\n\n\n\n\n\nApr 24, 2024\n\n\n나무껍질가이즈\n\n\n\n\n\n\n  \n\n\n\n\nproj_1\n\n\n\n\n\n\n\nR\n\n\nQMD\n\n\n\n\n단단한 나무껍질\n\n\n\n\n\n\nApr 22, 2024\n\n\n나무껍질가이즈\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/proj_1.html",
    "href": "posts/proj_1.html",
    "title": "proj_1",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ purrr::%||%()   masks base::%||%()\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\nmpg %&gt;% \n  ggplot(mapping = aes(x=class, y=hwy, fill=class))+\n  geom_boxplot() +\n  theme_minimal()"
  },
  {
    "objectID": "index.html#희희",
    "href": "index.html#희희",
    "title": "최희승 블로그 만드는거 도와주기",
    "section": "희희",
    "text": "희희"
  },
  {
    "objectID": "posts/proj_2.html",
    "href": "posts/proj_2.html",
    "title": "proj_2",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nprint(\"pandas :\", pd.__version__)\nprint(\"numpy :\" , np.__version__)\n\npandas : 1.5.3\nnumpy : 1.26.2\n\n\n\n\nnp.random.seed(0)\ndates = pd.date_range('20240101', periods=10)\ndata = pd.DataFrame(np.random.randn(10, 4), index=dates, columns=list('ABCD'))\n\nprint(data)\n\n\ndata.plot()\nplt.title('Random Data Visualization')\nplt.xlabel('Date')\nplt.ylabel('Values')\nplt.show()\n\n                   A         B         C         D\n2024-01-01  1.764052  0.400157  0.978738  2.240893\n2024-01-02  1.867558 -0.977278  0.950088 -0.151357\n2024-01-03 -0.103219  0.410599  0.144044  1.454274\n2024-01-04  0.761038  0.121675  0.443863  0.333674\n2024-01-05  1.494079 -0.205158  0.313068 -0.854096\n2024-01-06 -2.552990  0.653619  0.864436 -0.742165\n2024-01-07  2.269755 -1.454366  0.045759 -0.187184\n2024-01-08  1.532779  1.469359  0.154947  0.378163\n2024-01-09 -0.887786 -1.980796 -0.347912  0.156349\n2024-01-10  1.230291  1.202380 -0.387327 -0.302303"
  },
  {
    "objectID": "index.html#이-페이지는-인덱스다.-1",
    "href": "index.html#이-페이지는-인덱스다.-1",
    "title": "인덱스",
    "section": "",
    "text": "이 페이지는 인덱스다."
  },
  {
    "objectID": "posts/proj_3.html",
    "href": "posts/proj_3.html",
    "title": "군집화",
    "section": "",
    "text": "import pandas as pd\nimport geopandas as gpd\nfrom sklearn.cluster import KMeans\nimport folium\nfrom folium import CircleMarker\nfrom shapely.geometry import Point\n\ndata_raw = pd.read_csv(\"/home/sungil/Income_pred_Dacon/PersonalProj/완_하수구_위치_정보.csv\")\ndata = data_raw[[\"lat\",\"lon\"]].copy()\n\ngeometry = [Point(lon, lat) for lon, lat in zip(data_raw['lon'], data_raw['lat'])]\n\ndata_raw = gpd.GeoDataFrame(data_raw, geometry=geometry)\n\ndata_raw.crs= 'EPSG:4326'\ndata_raw.head()\n\n\n\n\n\n\n\n\n수위계번호\n수위계 설치지점\n박스높이(m)\nlat\nlon\ngeometry\n\n\n\n\n0\n23-0001\n강남구 압구정로20길 6앞 맨홀&lt;심덕빌딩(최용섭피부과)앞~백상빌딩간 횡단보도내&gt;\n2.0\n37.524714\n127.024854\nPOINT (127.02485 37.52471)\n\n\n1\n23-0002\n강남구 압구정로128앞 맨홀(신사동주민센터앞 횡단보도내, 현대고 서측정문앞)\n2.0\n37.524144\n127.022466\nPOINT (127.02247 37.52414)\n\n\n2\n23-0003\n강남구 남부순환로2947앞(대원빌딩앞 횡단보도내, 대치역사거리)\n2.5\n37.494475\n127.063235\nPOINT (127.06324 37.49448)\n\n\n3\n23-0004\n강남구 삼성로212앞 맨홀(은마아파트1동~미도아파트208동간,중안차로 안전지대내)\n2.5\n37.496052\n127.068492\nPOINT (127.06849 37.49605)\n\n\n4\n23-0005\n테헤란로435앞 맨홀(대종빌딩~삼영빌딩간 횡단보도앞 테헤란로측)\n2.5\n37.506400\n127.055012\nPOINT (127.05501 37.50640)\n\n\n\n\n\n\n\n\n\n\nkmeans = KMeans(n_clusters=3, random_state=42,n_init=10)\nkmeans.fit(data)\nlabels = kmeans.predict(data)\ncentroids = kmeans.cluster_centers_\ndef get_cluster_color(cluster_idx):\n    colors = ['red', 'green', 'blue', 'orange', 'purple', 'yellow', 'pink', 'cyan', 'magenta', 'gray']\n    return colors[cluster_idx % len(colors)]\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in data_raw.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=row[\"수위계번호\"],  # 툴팁에 군집 인덱스 표시\n                 color=color,\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\ndata_raw[\"label\"] = labels\ndata_raw[[\"수위계번호\",\"label\"]].sort_values(\"label\")\n\n\n\n\n\n\n\n\n수위계번호\nlabel\n\n\n\n\n0\n23-0001\n0\n\n\n1\n23-0002\n0\n\n\n6\n23-0007\n0\n\n\n4\n23-0005\n0\n\n\n7\n23-0008\n0\n\n\n10\n23-0011\n0\n\n\n9\n23-0010\n0\n\n\n8\n23-0009\n0\n\n\n12\n23-0013\n0\n\n\n11\n23-0012\n0\n\n\n2\n23-0003\n1\n\n\n3\n23-0004\n1\n\n\n14\n23-0015\n1\n\n\n13\n23-0014\n1\n\n\n15\n23-0016\n1\n\n\n16\n23-0017\n1\n\n\n20\n23-0021\n1\n\n\n17\n23-0018\n1\n\n\n18\n23-0019\n1\n\n\n19\n23-0020\n1\n\n\n5\n23-0006\n2\n\n\n21\n22-0007\n2\n\n\n22\n22-0010\n2\n\n\n23\n22-0011\n2\n\n\n24\n22-0012\n2\n\n\n25\n22-0013\n2\n\n\n26\n22-0014\n2\n\n\n\n\n\n\n\n\n\n\n\nkmeans = KMeans(n_clusters=4, random_state=42,n_init=10)\nkmeans.fit(data)\nlabels = kmeans.predict(data)\ncentroids = kmeans.cluster_centers_\ndef get_cluster_color(cluster_idx):\n    colors = ['red', 'green', 'blue', 'orange', 'purple', 'yellow', 'pink', 'cyan', 'magenta', 'gray']\n    return colors[cluster_idx % len(colors)]\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in data_raw.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=row[\"수위계번호\"],  # 툴팁에 군집 인덱스 표시\n                 color=color,\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\ndata_raw[\"label\"] = labels\ndata_raw[[\"수위계번호\",\"label\"]].sort_values(\"label\")\n\n\n\n\n\n\n\n\n수위계번호\nlabel\n\n\n\n\n0\n23-0001\n0\n\n\n1\n23-0002\n0\n\n\n6\n23-0007\n0\n\n\n7\n23-0008\n0\n\n\n11\n23-0012\n0\n\n\n10\n23-0011\n0\n\n\n9\n23-0010\n0\n\n\n8\n23-0009\n0\n\n\n12\n23-0013\n0\n\n\n13\n23-0014\n1\n\n\n14\n23-0015\n1\n\n\n15\n23-0016\n1\n\n\n19\n23-0020\n1\n\n\n18\n23-0019\n1\n\n\n17\n23-0018\n1\n\n\n16\n23-0017\n1\n\n\n20\n23-0021\n1\n\n\n25\n22-0013\n2\n\n\n26\n22-0014\n2\n\n\n5\n23-0006\n2\n\n\n24\n22-0012\n2\n\n\n21\n22-0007\n2\n\n\n22\n22-0010\n2\n\n\n23\n22-0011\n2\n\n\n3\n23-0004\n3\n\n\n2\n23-0003\n3\n\n\n4\n23-0005\n3\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nk_range = range(1, 10)\ninertia = []\n\nfor k in k_range:\n    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)\n    kmeans.fit(data)\n    inertia.append(kmeans.inertia_)\n\nplt.plot(k_range, inertia, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('Inertia')\nplt.title('Elbow Method for Optimal k')\nplt.xticks(k_range)\nplt.show()"
  },
  {
    "objectID": "posts/proj_3.html#하수구-위경도만으로-군집화",
    "href": "posts/proj_3.html#하수구-위경도만으로-군집화",
    "title": "군집화",
    "section": "",
    "text": "import pandas as pd\nimport geopandas as gpd\nfrom sklearn.cluster import KMeans\nimport folium\nfrom folium import CircleMarker\nfrom shapely.geometry import Point\n\ndata_raw = pd.read_csv(\"/home/sungil/Income_pred_Dacon/PersonalProj/완_하수구_위치_정보.csv\")\ndata = data_raw[[\"lat\",\"lon\"]].copy()\n\ngeometry = [Point(lon, lat) for lon, lat in zip(data_raw['lon'], data_raw['lat'])]\n\ndata_raw = gpd.GeoDataFrame(data_raw, geometry=geometry)\n\ndata_raw.crs= 'EPSG:4326'\ndata_raw.head()\n\n\n\n\n\n\n\n\n수위계번호\n수위계 설치지점\n박스높이(m)\nlat\nlon\ngeometry\n\n\n\n\n0\n23-0001\n강남구 압구정로20길 6앞 맨홀&lt;심덕빌딩(최용섭피부과)앞~백상빌딩간 횡단보도내&gt;\n2.0\n37.524714\n127.024854\nPOINT (127.02485 37.52471)\n\n\n1\n23-0002\n강남구 압구정로128앞 맨홀(신사동주민센터앞 횡단보도내, 현대고 서측정문앞)\n2.0\n37.524144\n127.022466\nPOINT (127.02247 37.52414)\n\n\n2\n23-0003\n강남구 남부순환로2947앞(대원빌딩앞 횡단보도내, 대치역사거리)\n2.5\n37.494475\n127.063235\nPOINT (127.06324 37.49448)\n\n\n3\n23-0004\n강남구 삼성로212앞 맨홀(은마아파트1동~미도아파트208동간,중안차로 안전지대내)\n2.5\n37.496052\n127.068492\nPOINT (127.06849 37.49605)\n\n\n4\n23-0005\n테헤란로435앞 맨홀(대종빌딩~삼영빌딩간 횡단보도앞 테헤란로측)\n2.5\n37.506400\n127.055012\nPOINT (127.05501 37.50640)\n\n\n\n\n\n\n\n\n\n\nkmeans = KMeans(n_clusters=3, random_state=42,n_init=10)\nkmeans.fit(data)\nlabels = kmeans.predict(data)\ncentroids = kmeans.cluster_centers_\ndef get_cluster_color(cluster_idx):\n    colors = ['red', 'green', 'blue', 'orange', 'purple', 'yellow', 'pink', 'cyan', 'magenta', 'gray']\n    return colors[cluster_idx % len(colors)]\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in data_raw.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=row[\"수위계번호\"],  # 툴팁에 군집 인덱스 표시\n                 color=color,\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\ndata_raw[\"label\"] = labels\ndata_raw[[\"수위계번호\",\"label\"]].sort_values(\"label\")\n\n\n\n\n\n\n\n\n수위계번호\nlabel\n\n\n\n\n0\n23-0001\n0\n\n\n1\n23-0002\n0\n\n\n6\n23-0007\n0\n\n\n4\n23-0005\n0\n\n\n7\n23-0008\n0\n\n\n10\n23-0011\n0\n\n\n9\n23-0010\n0\n\n\n8\n23-0009\n0\n\n\n12\n23-0013\n0\n\n\n11\n23-0012\n0\n\n\n2\n23-0003\n1\n\n\n3\n23-0004\n1\n\n\n14\n23-0015\n1\n\n\n13\n23-0014\n1\n\n\n15\n23-0016\n1\n\n\n16\n23-0017\n1\n\n\n20\n23-0021\n1\n\n\n17\n23-0018\n1\n\n\n18\n23-0019\n1\n\n\n19\n23-0020\n1\n\n\n5\n23-0006\n2\n\n\n21\n22-0007\n2\n\n\n22\n22-0010\n2\n\n\n23\n22-0011\n2\n\n\n24\n22-0012\n2\n\n\n25\n22-0013\n2\n\n\n26\n22-0014\n2\n\n\n\n\n\n\n\n\n\n\n\nkmeans = KMeans(n_clusters=4, random_state=42,n_init=10)\nkmeans.fit(data)\nlabels = kmeans.predict(data)\ncentroids = kmeans.cluster_centers_\ndef get_cluster_color(cluster_idx):\n    colors = ['red', 'green', 'blue', 'orange', 'purple', 'yellow', 'pink', 'cyan', 'magenta', 'gray']\n    return colors[cluster_idx % len(colors)]\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in data_raw.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=row[\"수위계번호\"],  # 툴팁에 군집 인덱스 표시\n                 color=color,\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\ndata_raw[\"label\"] = labels\ndata_raw[[\"수위계번호\",\"label\"]].sort_values(\"label\")\n\n\n\n\n\n\n\n\n수위계번호\nlabel\n\n\n\n\n0\n23-0001\n0\n\n\n1\n23-0002\n0\n\n\n6\n23-0007\n0\n\n\n7\n23-0008\n0\n\n\n11\n23-0012\n0\n\n\n10\n23-0011\n0\n\n\n9\n23-0010\n0\n\n\n8\n23-0009\n0\n\n\n12\n23-0013\n0\n\n\n13\n23-0014\n1\n\n\n14\n23-0015\n1\n\n\n15\n23-0016\n1\n\n\n19\n23-0020\n1\n\n\n18\n23-0019\n1\n\n\n17\n23-0018\n1\n\n\n16\n23-0017\n1\n\n\n20\n23-0021\n1\n\n\n25\n22-0013\n2\n\n\n26\n22-0014\n2\n\n\n5\n23-0006\n2\n\n\n24\n22-0012\n2\n\n\n21\n22-0007\n2\n\n\n22\n22-0010\n2\n\n\n23\n22-0011\n2\n\n\n3\n23-0004\n3\n\n\n2\n23-0003\n3\n\n\n4\n23-0005\n3\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nk_range = range(1, 10)\ninertia = []\n\nfor k in k_range:\n    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)\n    kmeans.fit(data)\n    inertia.append(kmeans.inertia_)\n\nplt.plot(k_range, inertia, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('Inertia')\nplt.title('Elbow Method for Optimal k')\nplt.xticks(k_range)\nplt.show()"
  },
  {
    "objectID": "posts/proj_3.html#표고지형-데이터-병합하기",
    "href": "posts/proj_3.html#표고지형-데이터-병합하기",
    "title": "군집화",
    "section": "표고(지형) 데이터 병합하기",
    "text": "표고(지형) 데이터 병합하기\n\nimport geopandas as gpd\n\ndata_raw = pd.read_csv(\"/home/sungil/Income_pred_Dacon/PersonalProj/완_하수구_위치_정보.csv\")\ngeometry = [Point(lon, lat) for lon, lat in zip(data_raw['lon'], data_raw['lat'])]\ndata_raw = gpd.GeoDataFrame(data_raw, geometry=geometry)\ndata_raw.crs= 'EPSG:4326'\n\npyogo = gpd.read_file(\"~/rawdata/gyeongsa/표고 5000/N3P_F002.shp\")\npyogo.drop([\"UFID\",\"NUME\",\"SCLS\",\"FMTA\"], axis=1, inplace=True) \n\nif pyogo.crs is None:\n    pyogo.set_crs(epsg = 5179, inplace = True)\n    \npyogo = pyogo.to_crs(epsg=4326)\n\nprint(data_raw.crs,pyogo.crs)\npyogo.head()\n\nEPSG:4326 EPSG:4326\n\n\n\n\n\n\n\n\n\nHEIGHT\ngeometry\n\n\n\n\n0\n213.080002\nPOINT (126.92718 37.41191)\n\n\n1\n68.430000\nPOINT (127.08504 37.41257)\n\n\n2\n150.309998\nPOINT (127.07865 37.41256)\n\n\n3\n39.209999\nPOINT (126.90436 37.41182)\n\n\n4\n342.640015\nPOINT (127.04173 37.41244)\n\n\n\n\n\n\n\n\n맨홀센서 위치별 300미터 버퍼 주기\n\nimport random\nimport folium\nfrom folium import  Polygon\n\ndata_raw_utm = data_raw.to_crs('EPSG:32652')  # 예시로 UTM Zone 52N 좌표계를 사용합니다.\n\n# 버퍼 추가\nbuffer_radius = 300\ndata_raw_utm['geometry'] = data_raw_utm['geometry'].buffer(buffer_radius)\n\ndata_raw_buffer = data_raw_utm.to_crs(data_raw.crs)\n# data_raw_buffer.head()\n\nM = folium.Map(location=[37.50452, 127.04899], \n               zoom_start=13,tiles=\"Cartodb Positron\")\n\nfolium.GeoJson(data_raw_buffer, \n               name=\"geojson\").add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n맨홀센서 버퍼 안에 드는 표고값\n\njoined_gdf = gpd.sjoin(pyogo,data_raw_buffer, predicate=\"within\")\njoined_gdf.drop([\"수위계 설치지점\"], axis=1, inplace=True)\njoined_gdf.head()\n\n\n\n\n\n\n\n\nHEIGHT\ngeometry\nindex_right\n수위계번호\n박스높이(m)\nlat\nlon\n\n\n\n\n5850\n28.719999\nPOINT (127.09539 37.48277)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n7888\n23.200001\nPOINT (127.09403 37.48400)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n8314\n24.650000\nPOINT (127.09367 37.48376)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n8885\n31.600000\nPOINT (127.09728 37.48350)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n8970\n22.840000\nPOINT (127.09450 37.48385)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n\n\n\n\n\n\njoined_gdf_2 = joined_gdf.groupby('수위계번호').mean().reset_index()\njoined_gdf_2.head()\n\n/tmp/ipykernel_24817/1738235292.py:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.mean is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n  joined_gdf_2 = joined_gdf.groupby('수위계번호').mean().reset_index()\n\n\n\n\n\n\n\n\n\n수위계번호\nHEIGHT\nindex_right\n박스높이(m)\nlat\nlon\n\n\n\n\n0\n22-0007\n16.685000\n21.0\n2.0\n37.494394\n127.028372\n\n\n1\n22-0010\n18.601481\n22.0\n3.0\n37.498114\n127.026919\n\n\n2\n22-0011\n18.190000\n23.0\n2.5\n37.496433\n127.028082\n\n\n3\n22-0012\n16.471220\n24.0\n3.0\n37.498106\n127.022192\n\n\n4\n22-0013\n22.450952\n25.0\n4.4\n37.500400\n127.018828\n\n\n\n\n\n\n\n\n\n표고 포함 군집화\n표준화\n\nfrom sklearn.preprocessing import StandardScaler\njoined_gdf_3 = joined_gdf_2.loc[:,[\"HEIGHT\",\"lat\",\"lon\"]]\n\nscaler = StandardScaler()\nscaled_data = scaler.fit_transform(joined_gdf_3)\nscaled_df = pd.DataFrame(scaled_data, columns=joined_gdf_3.columns)\nscaled_df.head()\n\n\n\n\n\n\n\n\nHEIGHT\nlat\nlon\n\n\n\n\n0\n-0.526674\n-0.593923\n-0.936982\n\n\n1\n-0.332162\n-0.363441\n-0.990645\n\n\n2\n-0.373925\n-0.467592\n-0.947693\n\n\n3\n-0.548372\n-0.363937\n-1.165225\n\n\n4\n0.058538\n-0.221806\n-1.289465\n\n\n\n\n\n\n\n\n\nk = 3\n\nkmeans = KMeans(n_clusters=3, random_state=42,n_init=10)\nkmeans.fit(scaled_df)\nlabels = kmeans.predict(scaled_df)\ncentroids = kmeans.cluster_centers_\n\njoined_gdf_2[\"label\"] = labels\n\ncolor_dict = {0: 'blue', 1: 'green', 2: 'red', 3: 'orange'}\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in joined_gdf_2.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                #  tooltip=[row[\"HEIGHT\"]],  # 툴팁에 군집 인덱스 표시\n                 color=color_dict[row[\"label\"]],\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1,\n                 tooltip=f'수위계번호: {row[\"수위계번호\"]}, 표고: {row[\"HEIGHT\"]}'\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\nk = 4\n\nkmeans = KMeans(n_clusters=4, random_state=42,n_init=10)\nkmeans.fit(scaled_df)\nlabels = kmeans.predict(scaled_df)\ncentroids = kmeans.cluster_centers_\n\njoined_gdf_2[\"label\"] = labels\n\ncolor_dict = {0: 'blue', 1: 'green', 2: 'red', 3: 'orange'}\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in joined_gdf_2.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                #  tooltip=[row[\"HEIGHT\"]],  # 툴팁에 군집 인덱스 표시\n                 color=color_dict[row[\"label\"]],\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1,\n                 tooltip=f'수위계번호: {row[\"수위계번호\"]}, 표고: {row[\"HEIGHT\"]}'\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\nimport matplotlib.pyplot as plt\nk_range = range(1, 10)\ninertia = []\n\nfor k in k_range:\n    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)\n    kmeans.fit(data)\n    inertia.append(kmeans.inertia_)\n\nplt.plot(k_range, inertia, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('Inertia')\nplt.title('Elbow Method for Optimal k')\nplt.xticks(k_range)\nplt.show()"
  },
  {
    "objectID": "posts/proj_3.html#결론",
    "href": "posts/proj_3.html#결론",
    "title": "군집화",
    "section": "결론",
    "text": "결론\n\n군집 1. 강남역 일대\n23-0006 22-0014 22-0011 22-0010 22-0012 22-0013\n\n\n군집 2. 압구정, 한강변 일대\n23-0002 23-0001 23-0007 23-0008 23-0009 23-0012 23-0011 23-0013"
  },
  {
    "objectID": "posts/proj_4.html",
    "href": "posts/proj_4.html",
    "title": "iframe을 사용해보아요~",
    "section": "",
    "text": "####################  UTM-K to wgs84  ####################\nimport geopandas as gpd\n\ndf = gpd.read_file(\"/home/sungil/Income_pred_Dacon/PersonalProj/emd/emd.shp\",encoding = \"euc-kr\")\n\nif df.crs is None:\n    df.set_crs(epsg = 5179, inplace = True)\n    \nprint(\"Original CRS set to:\", df.crs)\n\ndf_wgs84 = df.to_crs(epsg=4326)\nprint(\"Transformed CRS:\", df_wgs84.crs)\n\n####################  시각화  ####################\nimport random\nimport folium\nfrom folium import  Polygon\n\nunique_names = df['EMD_KOR_NM'].unique()\ncolors = {name: f'#{random.randint(0, 0xFFFFFF):06x}' for name in unique_names}\n\n# 스타일 함수 정의\ndef style_function(feature):\n    name = feature['properties']['EMD_KOR_NM']\n    return {\n        'fillColor': colors[name],\n        'color': 'black',  # 경계선 색상\n        'weight': 1,       # 경계선 두께\n        'fillOpacity': 0.2 # 채우기 불투명도\n    }\n\nM = folium.Map(location=[36.5, 127.04899], \n               zoom_start=7,tiles=\"Cartodb Positron\")\n\n# folium.GeoJson(df_wgs84, \n#                name=\"geojson\",\n#                popup=folium.GeoJsonPopup(fields=['EMD_KOR_NM'], labels=False),\n#                style_function=style_function).add_to(M)\n\nOriginal CRS set to: EPSG:5179\nTransformed CRS: EPSG:4326\n\n\n&lt;folium.features.GeoJson at 0x7f6b9223eb60&gt;"
  },
  {
    "objectID": "posts/군집화하기_ver2.html",
    "href": "posts/군집화하기_ver2.html",
    "title": "군집화",
    "section": "",
    "text": "import pandas as pd\nimport geopandas as gpd\nfrom sklearn.cluster import KMeans\nimport folium\nfrom folium import CircleMarker\nfrom shapely.geometry import Point\n\ndata_raw = pd.read_csv(\"/home/sungil/Income_pred_Dacon/PersonalProj/완_하수구_위치_정보.csv\")\ndata = data_raw[[\"lat\",\"lon\"]].copy()\n\ngeometry = [Point(lon, lat) for lon, lat in zip(data_raw['lon'], data_raw['lat'])]\n\ndata_raw = gpd.GeoDataFrame(data_raw, geometry=geometry)\n\ndata_raw.crs= 'EPSG:4326'\ndata_raw.head()\n\n\n\n\n\n\n\n\n수위계번호\n수위계 설치지점\n박스높이(m)\nlat\nlon\ngeometry\n\n\n\n\n0\n23-0001\n강남구 압구정로20길 6앞 맨홀&lt;심덕빌딩(최용섭피부과)앞~백상빌딩간 횡단보도내&gt;\n2.0\n37.524714\n127.024854\nPOINT (127.02485 37.52471)\n\n\n1\n23-0002\n강남구 압구정로128앞 맨홀(신사동주민센터앞 횡단보도내, 현대고 서측정문앞)\n2.0\n37.524144\n127.022466\nPOINT (127.02247 37.52414)\n\n\n2\n23-0003\n강남구 남부순환로2947앞(대원빌딩앞 횡단보도내, 대치역사거리)\n2.5\n37.494475\n127.063235\nPOINT (127.06324 37.49448)\n\n\n3\n23-0004\n강남구 삼성로212앞 맨홀(은마아파트1동~미도아파트208동간,중안차로 안전지대내)\n2.5\n37.496052\n127.068492\nPOINT (127.06849 37.49605)\n\n\n4\n23-0005\n테헤란로435앞 맨홀(대종빌딩~삼영빌딩간 횡단보도앞 테헤란로측)\n2.5\n37.506400\n127.055012\nPOINT (127.05501 37.50640)\n\n\n\n\n\n\n\n\nkmeans = KMeans(n_clusters=4, random_state=42,n_init=10)\nkmeans.fit(data)\nlabels = kmeans.predict(data)\ncentroids = kmeans.cluster_centers_\ndef get_cluster_color(cluster_idx):\n    colors = ['red', 'green', 'blue', 'orange', 'purple', 'yellow', 'pink', 'cyan', 'magenta', 'gray']\n    return colors[cluster_idx % len(colors)]\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in data_raw.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=row[\"수위계번호\"],  # 툴팁에 군집 인덱스 표시\n                 color=color,\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\nimport matplotlib.pyplot as plt\nk_range = range(1, 10)\ninertia = []\n\nfor k in k_range:\n    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)\n    kmeans.fit(data)\n    inertia.append(kmeans.inertia_)\n\nplt.plot(k_range, inertia, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('Inertia')\nplt.title('Elbow Method for Optimal k')\nplt.xticks(k_range)\nplt.show()"
  },
  {
    "objectID": "posts/군집화하기_ver2.html#표고-데이터-병합하기",
    "href": "posts/군집화하기_ver2.html#표고-데이터-병합하기",
    "title": "군집화",
    "section": "표고 데이터 병합하기",
    "text": "표고 데이터 병합하기\n\nimport geopandas as gpd\npyogo = gpd.read_file(\"~/rawdata/gyeongsa/표고 5000/N3P_F002.shp\")\npyogo.drop([\"UFID\",\"NUME\",\"SCLS\",\"FMTA\"], axis=1, inplace=True) \n\nif pyogo.crs is None:\n    pyogo.set_crs(epsg = 5179, inplace = True)\n    \nprint(\"Original CRS set to:\", pyogo.crs)\n\npyogo = pyogo.to_crs(epsg=4326)\nprint(\"Transformed CRS:\", pyogo.crs)\npyogo.head()\n\nOriginal CRS set to: EPSG:5174\nTransformed CRS: EPSG:4326\n\n\n\n\n\n\n\n\n\nHEIGHT\ngeometry\n\n\n\n\n0\n213.080002\nPOINT (126.92718 37.41191)\n\n\n1\n68.430000\nPOINT (127.08504 37.41257)\n\n\n2\n150.309998\nPOINT (127.07865 37.41256)\n\n\n3\n39.209999\nPOINT (126.90436 37.41182)\n\n\n4\n342.640015\nPOINT (127.04173 37.41244)\n\n\n\n\n\n\n\n\nimport random\nimport folium\nfrom folium import  Polygon\n\ndata_raw_utm = data_raw.to_crs('EPSG:32652')  # 예시로 UTM Zone 52N 좌표계를 사용합니다.\n\n# 버퍼 추가\nbuffer_radius = 300\ndata_raw_utm['geometry'] = data_raw_utm['geometry'].buffer(buffer_radius)\n\ndata_raw_buffer = data_raw_utm.to_crs(data_raw.crs)\n# data_raw_buffer.head()\n\nM = folium.Map(location=[37.50452, 127.04899], \n               zoom_start=13,tiles=\"Cartodb Positron\")\n\nfolium.GeoJson(data_raw_buffer, \n               name=\"geojson\").add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\njoined_gdf = gpd.sjoin(pyogo,data_raw_buffer, predicate=\"within\")\njoined_gdf.drop([\"수위계 설치지점\"], axis=1, inplace=True)\njoined_gdf.head()\n\n\n\n\n\n\n\n\nHEIGHT\ngeometry\nindex_right\n수위계번호\n박스높이(m)\nlat\nlon\n\n\n\n\n5850\n28.719999\nPOINT (127.09539 37.48277)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n7888\n23.200001\nPOINT (127.09403 37.48400)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n8314\n24.650000\nPOINT (127.09367 37.48376)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n8885\n31.600000\nPOINT (127.09728 37.48350)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n8970\n22.840000\nPOINT (127.09450 37.48385)\n20\n23-0021\n2.6\n37.484353\n127.094982\n\n\n\n\n\n\n\n\njoined_gdf.dtypes\n\nHEIGHT          float64\ngeometry       geometry\nindex_right       int64\n수위계번호            object\n박스높이(m)         float64\nlat             float64\nlon             float64\ndtype: object\n\n\n\njoined_gdf_2 = joined_gdf.groupby('수위계번호').mean().reset_index()\njoined_gdf_2.head()\n\n/tmp/ipykernel_19905/1738235292.py:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.mean is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n  joined_gdf_2 = joined_gdf.groupby('수위계번호').mean().reset_index()\n\n\n\n\n\n\n\n\n\n수위계번호\nHEIGHT\nindex_right\n박스높이(m)\nlat\nlon\n\n\n\n\n0\n22-0007\n16.685000\n21.0\n2.0\n37.494394\n127.028372\n\n\n1\n22-0010\n18.601481\n22.0\n3.0\n37.498114\n127.026919\n\n\n2\n22-0011\n18.190000\n23.0\n2.5\n37.496433\n127.028082\n\n\n3\n22-0012\n16.471220\n24.0\n3.0\n37.498106\n127.022192\n\n\n4\n22-0013\n22.450952\n25.0\n4.4\n37.500400\n127.018828\n\n\n\n\n\n\n\n\nfrom folium import CircleMarker\n\nM = folium.Map(location=[37.50452, 127.04899], \n               zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx,row in joined_gdf_2.iterrows():\n    CircleMarker(location=[row[\"lat\"],row[\"lon\"]],\n                 radius=3,\n                 tooltip=row[\"HEIGHT\"],  # 툴팁에 군집 인덱스 표시\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\nM = folium.Map(location=[37.50452, 127.04899], \n               zoom_start=13,tiles=\"Cartodb Positron\")\n\nfolium.GeoJson(data_raw_buffer, \n               name=\"geojson\").add_to(M)\n\nfolium.GeoJson(joined_gdf, \n               name=\"geojson\").add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/군집화하기_ver2.html#표고-포함-군집화",
    "href": "posts/군집화하기_ver2.html#표고-포함-군집화",
    "title": "군집화",
    "section": "표고 포함 군집화",
    "text": "표고 포함 군집화\n\njoined_gdf_3 = joined_gdf_2.loc[:,[\"HEIGHT\",\"lat\",\"lon\"]]\njoined_gdf_3.head()\n\n\n\n\n\n\n\n\nHEIGHT\nlat\nlon\n\n\n\n\n0\n16.685000\n37.494394\n127.028372\n\n\n1\n18.601481\n37.498114\n127.026919\n\n\n2\n18.190000\n37.496433\n127.028082\n\n\n3\n16.471220\n37.498106\n127.022192\n\n\n4\n22.450952\n37.500400\n127.018828\n\n\n\n\n\n\n\n\nfrom sklearn.preprocessing import StandardScaler\n\nscaler = StandardScaler()\nscaled_data = scaler.fit_transform(joined_gdf_3)\nscaled_df = pd.DataFrame(scaled_data, columns=joined_gdf_3.columns)\n\n\nkmeans = KMeans(n_clusters=4, random_state=42,n_init=10)\nkmeans.fit(scaled_df)\nlabels = kmeans.predict(scaled_df)\ncentroids = kmeans.cluster_centers_\n\njoined_gdf_3[\"label\"] = labels\njoined_gdf_3\n\n\n\n\n\n\n\n\nHEIGHT\nlat\nlon\nlabel\n\n\n\n\n0\n16.685000\n37.494394\n127.028372\n3\n\n\n1\n18.601481\n37.498114\n127.026919\n3\n\n\n2\n18.190000\n37.496433\n127.028082\n3\n\n\n3\n16.471220\n37.498106\n127.022192\n3\n\n\n4\n22.450952\n37.500400\n127.018828\n3\n\n\n5\n16.685000\n37.494399\n127.028329\n3\n\n\n6\n15.413061\n37.524714\n127.024854\n0\n\n\n7\n14.988200\n37.524144\n127.022466\n0\n\n\n8\n13.772666\n37.494475\n127.063235\n1\n\n\n9\n14.181333\n37.496052\n127.068492\n1\n\n\n10\n21.414546\n37.506400\n127.055012\n3\n\n\n11\n20.450417\n37.494020\n127.033451\n3\n\n\n12\n18.929487\n37.529062\n127.034439\n0\n\n\n13\n18.674390\n37.528394\n127.036788\n0\n\n\n14\n21.153250\n37.524246\n127.037206\n0\n\n\n15\n18.479355\n37.528181\n127.050339\n0\n\n\n16\n23.637895\n37.523765\n127.048436\n0\n\n\n17\n30.667600\n37.519166\n127.046670\n0\n\n\n18\n18.479355\n37.528181\n127.050339\n0\n\n\n19\n17.306829\n37.494290\n127.086173\n1\n\n\n20\n19.136098\n37.492741\n127.086205\n1\n\n\n21\n18.373846\n37.493352\n127.086506\n1\n\n\n22\n58.832963\n37.481378\n127.084280\n2\n\n\n23\n48.745610\n37.483459\n127.086705\n2\n\n\n24\n18.380588\n37.488482\n127.102176\n1\n\n\n25\n22.945000\n37.486758\n127.099563\n1\n\n\n26\n27.557143\n37.484353\n127.094982\n1\n\n\n\n\n\n\n\n\nk = 4\n\ncolor_dict = {0: 'blue', 1: 'green', 2: 'red', 3: 'black'}\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in joined_gdf_3.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=[row[\"HEIGHT\"]],  # 툴팁에 군집 인덱스 표시\n                 color=color_dict[row[\"label\"]],\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\nk = 3\n\nkmeans = KMeans(n_clusters=3, random_state=42,n_init=10)\nkmeans.fit(scaled_df)\nlabels = kmeans.predict(scaled_df)\ncentroids = kmeans.cluster_centers_\ndef get_cluster_color(cluster_idx):\n    colors = ['red', 'green', 'blue', 'orange', 'purple', 'yellow', 'pink', 'cyan', 'magenta', 'gray']\n    return colors[cluster_idx % len(colors)]\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in joined_gdf_2.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=[row[\"HEIGHT\"]],  # 툴팁에 군집 인덱스 표시\n                 color=color,\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\nimport matplotlib.pyplot as plt\nk_range = range(1, 10)\ninertia = []\n\nfor k in k_range:\n    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)\n    kmeans.fit(scaled_df)\n    inertia.append(kmeans.inertia_)\n\nplt.plot(k_range, inertia, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('Inertia')\nplt.title('Elbow Method for Optimal k')\nplt.xticks(k_range)\nplt.show()"
  },
  {
    "objectID": "posts/군집화하기_ver2.html#박스높이-포함-군집화",
    "href": "posts/군집화하기_ver2.html#박스높이-포함-군집화",
    "title": "군집화",
    "section": "박스높이 포함 군집화",
    "text": "박스높이 포함 군집화\n\njoined_gdf_4 = joined_gdf_2.loc[:,[\"HEIGHT\",\"lat\",\"lon\",\"박스높이(m)\"]]\njoined_gdf_4.head()\n\n\n\n\n\n\n\n\nHEIGHT\nlat\nlon\n박스높이(m)\n\n\n\n\n0\n16.685000\n37.494394\n127.028372\n2.0\n\n\n1\n18.601481\n37.498114\n127.026919\n3.0\n\n\n2\n18.190000\n37.496433\n127.028082\n2.5\n\n\n3\n16.471220\n37.498106\n127.022192\n3.0\n\n\n4\n22.450952\n37.500400\n127.018828\n4.4\n\n\n\n\n\n\n\n\nfrom sklearn.preprocessing import StandardScaler\n\nscaler = StandardScaler()\nscaled_data_2 = scaler.fit_transform(joined_gdf_4)\nscaled_df_2 = pd.DataFrame(scaled_data_2, columns=joined_gdf_4.columns)\n\n\nk = 3\n\nkmeans = KMeans(n_clusters=3, random_state=42,n_init=10)\nkmeans.fit(scaled_df_2)\nlabels = kmeans.predict(scaled_df_2)\ncentroids = kmeans.cluster_centers_\n\njoined_gdf_4[\"label\"] = labels\njoined_gdf_4\ncolor_dict = {0: 'blue', 1: 'green', 2: 'red', 3: 'black'}\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in joined_gdf_4.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=[row[\"HEIGHT\"]],  # 툴팁에 군집 인덱스 표시\n                 color=color_dict[row[\"label\"]],\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\nk = 4\n\nkmeans = KMeans(n_clusters=4, random_state=42,n_init=10)\nkmeans.fit(scaled_df_2)\nlabels = kmeans.predict(scaled_df_2)\ncentroids = kmeans.cluster_centers_\n\njoined_gdf_4[\"label\"] = labels\njoined_gdf_4\ncolor_dict = {0: 'blue', 1: 'green', 2: 'red', 3: 'black'}\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in joined_gdf_4.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=[row[\"HEIGHT\"]],  # 툴팁에 군집 인덱스 표시\n                 color=color_dict[row[\"label\"]],\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\nk = 5\n\nkmeans = KMeans(n_clusters=5, random_state=42,n_init=10)\nkmeans.fit(scaled_df_2)\nlabels = kmeans.predict(scaled_df_2)\ncentroids = kmeans.cluster_centers_\n\njoined_gdf_4[\"label\"] = labels\njoined_gdf_4\ncolor_dict = {0: 'blue', 1: 'green', 2: 'red', 3: 'black', 4: 'yellow'}\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in joined_gdf_4.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=[row[\"HEIGHT\"]],  # 툴팁에 군집 인덱스 표시\n                 color=color_dict[row[\"label\"]],\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\nimport matplotlib.pyplot as plt\nk_range = range(1, 10)\ninertia = []\n\nfor k in k_range:\n    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)\n    kmeans.fit(scaled_df_2)\n    inertia.append(kmeans.inertia_)\n\nplt.plot(k_range, inertia, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('Inertia')\nplt.title('Elbow Method for Optimal k')\nplt.xticks(k_range)\nplt.show()"
  },
  {
    "objectID": "posts/군집화하기_ver2.html#하수구-위경도만으로-군집화",
    "href": "posts/군집화하기_ver2.html#하수구-위경도만으로-군집화",
    "title": "군집화",
    "section": "",
    "text": "import pandas as pd\nimport geopandas as gpd\nfrom sklearn.cluster import KMeans\nimport folium\nfrom folium import CircleMarker\nfrom shapely.geometry import Point\n\ndata_raw = pd.read_csv(\"/home/sungil/Income_pred_Dacon/PersonalProj/완_하수구_위치_정보.csv\")\ndata = data_raw[[\"lat\",\"lon\"]].copy()\n\ngeometry = [Point(lon, lat) for lon, lat in zip(data_raw['lon'], data_raw['lat'])]\n\ndata_raw = gpd.GeoDataFrame(data_raw, geometry=geometry)\n\ndata_raw.crs= 'EPSG:4326'\ndata_raw.head()\n\n\n\n\n\n\n\n\n수위계번호\n수위계 설치지점\n박스높이(m)\nlat\nlon\ngeometry\n\n\n\n\n0\n23-0001\n강남구 압구정로20길 6앞 맨홀&lt;심덕빌딩(최용섭피부과)앞~백상빌딩간 횡단보도내&gt;\n2.0\n37.524714\n127.024854\nPOINT (127.02485 37.52471)\n\n\n1\n23-0002\n강남구 압구정로128앞 맨홀(신사동주민센터앞 횡단보도내, 현대고 서측정문앞)\n2.0\n37.524144\n127.022466\nPOINT (127.02247 37.52414)\n\n\n2\n23-0003\n강남구 남부순환로2947앞(대원빌딩앞 횡단보도내, 대치역사거리)\n2.5\n37.494475\n127.063235\nPOINT (127.06324 37.49448)\n\n\n3\n23-0004\n강남구 삼성로212앞 맨홀(은마아파트1동~미도아파트208동간,중안차로 안전지대내)\n2.5\n37.496052\n127.068492\nPOINT (127.06849 37.49605)\n\n\n4\n23-0005\n테헤란로435앞 맨홀(대종빌딩~삼영빌딩간 횡단보도앞 테헤란로측)\n2.5\n37.506400\n127.055012\nPOINT (127.05501 37.50640)\n\n\n\n\n\n\n\n\nkmeans = KMeans(n_clusters=4, random_state=42,n_init=10)\nkmeans.fit(data)\nlabels = kmeans.predict(data)\ncentroids = kmeans.cluster_centers_\ndef get_cluster_color(cluster_idx):\n    colors = ['red', 'green', 'blue', 'orange', 'purple', 'yellow', 'pink', 'cyan', 'magenta', 'gray']\n    return colors[cluster_idx % len(colors)]\n\nM = folium.Map(location=[37.50452, 127.055],\n                              zoom_start=13,tiles=\"Cartodb Positron\")\n\nfor idx, row in data_raw.iterrows():\n    cluster_idx = labels[idx]  # 데이터 포인트의 군집 인덱스\n    color = get_cluster_color(cluster_idx) \n\n    CircleMarker(location=[row['lat'], row['lon']],\n                 radius=3,\n                 tooltip=row[\"수위계번호\"],  # 툴팁에 군집 인덱스 표시\n                 color=color,\n                 fill=True,\n                 fill_opacity=1,\n                 opacity=1\n                ).add_to(M)\n\n# Plot Centroids\nfor centroid in centroids:\n    folium.Marker(location=[centroid[0], centroid[1]],\n                  icon=folium.Icon(color='red', icon='info-sign')\n                 ).add_to(M)\n\nM\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\nimport matplotlib.pyplot as plt\nk_range = range(1, 10)\ninertia = []\n\nfor k in k_range:\n    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)\n    kmeans.fit(data)\n    inertia.append(kmeans.inertia_)\n\nplt.plot(k_range, inertia, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('Inertia')\nplt.title('Elbow Method for Optimal k')\nplt.xticks(k_range)\nplt.show()"
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "",
    "text": "매년 여름 주로 발생하는 피해는 단기 집중 호우와 홍수로 인한 피해일 것이다. 홍수로 인해서 침수 와 관련되어 맨홀 및 하수구와 관련된 사고 등 다양한 사고가 해마다 증가하고 있는 추세이다. 2022년 8월경 강남역 인근 맨홀에 남매가 맨홀 속으로 빨려들어 실종되어 결국 변사체로 발견하는 안타까운 사고가 발생하였다. 이 때 당시 강남역 일대에는 시간당 100mm 이상의 기록적인 폭우가 쏟아지면서 큰 인명과 재산 피해가 잇따라 발생했다.\n강남역 일대는 2010년부터 다섯 번이나 침수되었다. 침수나 정전 사고가 속출하면서 강남구 일대에 있는 주민들에게 엄청난 피해를 입혔다. 이는 처리 용량을 넘어선 기록적인 강수량이 침수 피해의 가 장 큰 요인이지만, 서울시의 부실한 대응 또한 무시할 수 없는 원인이라고 생각한다. 또한 경기 고양시는 2023년 1월 6일 기사에 따르면 하수도 막힘이나 역류, 맨홀 파손, 누수, 침하 등 사고가 지난 1년간 총 1천400여 건, 하루의 4번꼴로 신고가 접수되었다. 이들 사고 가운데 하수관 로에 기름때가 끼거나 음식물 쓰레기와 일회용 물티슈 등 이물질이 쌓여 생긴 막힘이 가장 많았다. 막힌 하수도를 신속하게 준설하지 않아 오·폐수가 가정집으로 흘러들어온 경우도 종종 있었다.\n\n\n\n위의 사례들뿐만 아니라 전 세계적으로도 비슷한 사고가 증가하는 추세이다. 지금까지 지속적으로 비슷한 사고가 발생해왔기에 하수구 관련 문제를 효율적으로 해결할 수 있는 시스템과 구체적인 방안 이 필요하다.\n2024년 기준 환경부 정책보고서의 내용에 따르면 이번 우리나라의 예산 중 하수관리정비(도시침수대 응)는 2023년 1,541억에서 2024년 3,275억원으로 예산이 증가하게 되었다. 또한 강남역, 광화문, 도 림천 저수시설 관리의 예산은 2023년 85억에서 2024년 262억원으로 증가하였다. 하지만 예산이 증 가하여도 비효율적인 점검과 관리를 하게 된다면 환경적 측면의 문제도 발생할뿐더러 시간적, 금전적 비용의 낭비가 극대화될 것이다. 또한 국민들은 자신의 안정성 보장받지 못하게 되고 이로 인한 반발 도 심해지게 될 것이다. 이와 같은 문제를 해결하기 위해 이번 연구에서 하수관로 수위 센서를 활용한 AI모델을 만들고 위/ 경도와 고/저도를 통한 군집 분석으로 구역을 나누어 예측 분석을 시행할 예정이다. 중장기적 관점으 로 보았을 때 효율적인 점검을 제안하고, 실시간 및 단기적 관점으로 살펴보았을 땐 위험구역 판별의 도움을 주는 시스템을 도입하여 두 가지 관점에서의 활용방안이 도입된다면 기존의 시스템보다 더 신 속하고 유용한 정보를 알려주게 될 것이다.\n\n\n\n2015년부터 서울시는 전국 최초로 하수관로 수위를 센서로 측정하여 모니터링하는 시스템을 12개 자치구 43개소에 구축한 데 이어 전 자치구에 48개소를 추가로 구축하였고 총 91개 하수관로 수위정 보를 실시간으로 모니터링하고 있다고 밝혔다. 현재 하수관로 모니터링 시스템은 서울시에서 관리하 고 있는 하수관거 총연장 1만487km 중 저지대 등 침수취약지역으로 하수 수위관리가 필요하다고 판 단한 지역을 위주로 설치됐다. 하수관로 맨홀에 수위계를 설치해 수위를 1분 간격으로 자동 측정해 서울시 통합안전상황실과 25개 자치구 재난안전대책본부로 전송되는 시스템이다. 기존엔 지하시설물 인 하수관로 특성상 육안확인이 어려워 집중호우 시 수위가 급격히 상승해 발생하는 문제점을 발견하 지 못했다면, 이제는 하수관로의 현재 수위가 얼마나 되는지 실시간으로 확인할 수 있게 되었다. 하 수도 수위가 관로높이의 60%이상 찰 때부터 해당지역 담당 공무원들에게 자동으로 문자가 발송되도 록 시스템을 구축하고, 하수관로 수위 변동 시 현장에 출동해 사전에 수해예방 조치를 취할 수 있도 록 했다. 수위비율이 80~90%를 넘어간다면 침수위험상황이라고 판단하여 자치구 재난안전대책본부에 서 해당지역 주민들에게 문자, 안내방송 등으로 즉시 상황을 전파해 신속히 대응하게 되는 시스템을 만들었다.\n\n\n\n\n\n단기적/실시간적 관점 하루 15분 단위로 하수관로 수위를 예측하고, 군집 분석을 통해 수위가 급격히 상승하여 침수 가능 성이 높은 구역을 식별한다. 이를 통해 실시간으로 위험 구역을 파악하고, 관련 기관과 시민들에게 신속하게 경보를 제공한다. 수위가 급격히 상승하여 침수 위험이 높아진다고 예측되는 경우 관련 당국 및 관계자, 혹은 경찰이 나 소방관들에게 자동으로 경보를 발령하고, 즉각적인 대응 조치를 취할 수 있도록 한다. 이를 통해 시민들의 생명과 재산을 보호하고, 침수 피해를 최소화할 수 있게 된다.\n중장기적 관점 중장기적 관점에서 딥러닝 모델을 활용하여 과거의 기후 데이터와 하수관로 수위 데이터를 학습을 시킨다. 이를 통해 하수관로 수위의 시간적 변화를 예측하고, 향후 기간 동안의 수위를 추정함으로써 예측 모델을 통해 특정 분기 또는 기간 동안 침수 가능성이 높은 날짜와 시간대를 사전에 파악할 수 있게 된다. 중장기적 예측은 관련 기관 및 당국이 사전에 대응책을 마련하는데 도움을 줄 것이다. 또 한 하수구 및 관련 시설물의 점검 및 유지보수 작업을 미리 계획할 수 있게 됨으로써 사고 발생 가 능성을 사전에 예방할 수 있다.\n대시보드 제작 대시보드를 통해 하수관로 수위의 실시간 변화를 모니터링하고, 시각화된 데이터를 통해 관리자가 수위 상황을 쉽게 이해하고 대응할 수 있도록 한다. 이로써 관리자들은 신속하고 효과적인 의사 결정 을 내릴 수 있게 된다. 또한 대시보드를 통해 수위 예측 결과 및 위험 구역 정보를 관련 당국, 관리 자, 시민들에게 공유함으로써 투명하고 신속한 대응을 도모할 수 있게 될 것이다.\n데이터 기반 의사 결정 연구는 데이터를 기반으로 한 의사 결정을 지원하는 것을 목표로 한다. 수집된 데이터와 예측 모델 을 활용하여 하수관로 관리에 대한 효과적인 의사 결정을 내리는 것이 중요하다. 데이터 기반의 접근 은 관리자들이 효과적인 대응 및 관리를 할 수 있도록 도와줄 것이며, 이를 통해 하수관로 관리의 효 율성을 높이고 문제 해결에 보다 신속하게 대응할 수 있다.\n협력과 정보 공유 연구는 관련 기관 및 당국과의 협력을 강화하고 연구 결과를 공유하는 것을 목표로 한다. 협력과 정 보 공유를 통해 연구 결과를 보다 효과적으로 활용할 수 있으며, 이를 통해 지역 사회의 안전과 안정 성을 증진시킬 수 있다. 또한, 협력과 정보 공유를 통해 관련 기관과의 소통을 원활하게 하고, 문제 해결에 보다 효과적으로 대응할 수 있다."
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#데이터-설명-및-수집",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#데이터-설명-및-수집",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "1. 데이터 설명 및 수집",
    "text": "1. 데이터 설명 및 수집\n먼저 하수관로의 센서를 이용한 수위현황 데이터와 그 하수관로들의 위치 데이터를 서울 열린데이터 광장에서 실시간 오픈 API로 불러와 조회를 한다. 그리고 크롤링을 하여 1분 단위로 수집되는 데이터 중에서 강남구에 위치한 데이터만 추출하고 csv파일로 저장하여 프로젝트를 진행하였다. 또한 모든 하수관로마다 센서가 부착된 것이 아니기 때문에 부착된 곳의 위치 데이터를 수집하여 시각화를 하여 위치를 확인했다."
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#분석-방법",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#분석-방법",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "2. 분석 방법",
    "text": "2. 분석 방법\n\n- k-means clustering 모델을 활용한 구역 군집화\nK 평균 군집화(K-means clustering)는 비지도 학습의 일종으로, 데이터를 클러스터라고 불리는 그 룹으로 군집화하는 알고리즘이다. 침수 위험이 있는 구역을 구분하기 위해 지형, 하수구의 위치와 깊 이 데이터를 사용하여 군집분석을 시행하였다. 군집화를 통해 결측치와 이상치가 많은 센서 데이터를 구역별로 서로 보완하고, 각각의 하수관로 수위에서 군집화된 구역으로 분석 대상(종속 변수)을 선정 하였다. 다음 그림은 센서가 부착된 하수관로의 위치를 군집화를 통해 점으로 표시한 그림이다.\nK-means clustering에서 K(군집의 수)를 결정하는 것은 중요한 문제이다. 적절한 K를 선택하는 것은 군집화의 품질과 해석력에 큰 영향을 미친다. 적절한 K의 결정을 위해, 1부터 10까지의 K를 적용 해보고 클러스터 내의 오차합(SSE)을 평가하는 Elbow Method를 사용한 결과 K=4에서 가장 최적화 된 군집 분석 결과를 얻을 수 있었다. 군집분석 결과 강남역 일대, 압구정동 한강변, 일원동 일대와 세곡동 대모산 일대로 나뉘게 된다. 일 원동 일대와 세곡동 대모산은 고저도가 높고 하수관로 수위센서 데이터를 살펴보았을 때 위험도가 낮 은 것으로 판단되어 강남역 일대와 압구정동 한강변을 분석 대상으로 결정하였다.\n\n\n- 상관관계 분석\n구역을 나눈 뒤 강남역 일대, 압구정동 한강변의 하수관로 수위에 영향이 있을만한 시계열 변수를 수집하였다. 기상청으로부터 풍향, 풍속, 기온, 강수량 등의 날씨와 열린서울데이터광장으로부터 강남 구 및 압구정의 총 생활 인구수, 국가수자원관리종합정보시스템으로부터 한강의 수위 데이터를 수집 하였다.\n하수관로 수위센서 데이터와 수집한 데이터를 병합하고 15분 간격으로 조절한 뒤, 수집한 데이터를 통해 하수관로 수위와 각 변수에 대한 선형 관계를 알아보고자 상관계수 행렬 그래프를 통해서 살펴 보았다. 상관계수를 살펴보았을 때 강수량과의 상관계수가 0.64로 가장 높았고 청담대교 인근 한강수 위, 시정, 총 생활 인구수가 그 뒤를 이어 상관관계가 높은 것을 알 수 있었다. 기후, 수위변수뿐만 아니라 해당 구역의 총 생활 인구수와도 상관관계를 보이는 것을 확인하였다.\n\n\n- 데이터 재구조화\n각 변수를 표준화시킨 뒤 데이터의 구조를 바꾸어주었다. 일반 회귀분석에서는 첫 번째 독립변수 행렬을 통해 첫 번째 종속변수를 학습하고 예측한다. 반면에 시계열 회귀분석은 과거의 독립변수 행렬을 통해 현재의 종속변수를 학습하고 예측해야 한다. 현재로부터 얼마만큼의 과거 데이터를 사용할건지를 의미하는 Sequence를 과거 5시간 데이터인 20 으로(60분/15분 * 5) 정하였다. 따라서 총 데이터 구조는 학습데이터(14행, 15열, 35097개), 테스트 데이터(14행, 15열, 8832개)로 구조화하였다.\n\n\n- 하수관로의 수위 비율 예측(LSTM, Transformer)\n첫 번째로, 시계열 데이터를 분석할 때 활용되는 대표적인 모델인 LSTM 모델이다. LSTM은 Long Short-Term Memory의 약자로, 순환 신경망(RNN)의 한 종류이다. RNN은 순차적인 데이터, 즉 시 퀀스 데이터를 처리하는 데 사용된다. 그러나 일반적인 RNN은 긴 Sequence를 처리할 때 장기 의존 성 문제로 인해 성능이 저하될 수 있는데 LSTM은 이러한 문제를 해결하기 위해 고안된 모델이라 할 수 있다. 이 모델의 장점으로는 장기 의존성을 효과적으로 처리할 수 있다는 점과 긴 Sequence 데 이터를 처리할 때 RNN에 비해 더 좋은 성능을 보인다는 점, 다양한 응용 분야에서 효과적으로 사용 된다는 것이 장점이라 할 수 있다.\n두 번째로, 트랜스포머 기반 시계열 회귀분석 모델이다. 2017년 구글에서 발표한 알고리즘으로 순환 신경망(RNN)이나 장단기 메모리(LSTM)와는 달리 순차적으로 데이터를 처리하지 않고, 병렬적으로 처리하되 데이터의 순서 정보(Positional encoding)를 모델에 제공하는 방식으로 시계열 데이터에도 효과적으로 적용할 수 있는 알고리즘이다. 트랜스포머 기반 모델을 시계열 분석에 사용할 때의 장점 으로는 벙렬 처리를 통한 속도 증가와 장기 의존성을 효과적으로 모델링할 수 있다는 점이다. 우리는 두 모델을 이용하여서 예측 분석을 시행하였다. 2022년 6월 1일 00시 00분부터 2023년 5월 31일 23시 45분까지 (전체 중 80%)를 학습데이터로 사용하고, 2023년 6월 1일 00시 00분부터 2023 년 8월 31일 23시 45분까지 (전체의 20%)를 평가 데이터로 사용하였다."
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#서비스-활용-시-사용되는-대시보드-예시",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#서비스-활용-시-사용되는-대시보드-예시",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "3. 서비스 활용 시 사용되는 대시보드 예시",
    "text": "3. 서비스 활용 시 사용되는 대시보드 예시\n지도에 사전에 군집화된 구역별로 나누어진 포인트를 선택하여 해당 구역의 단기,장기 수위 예측을 확인할 수 있는 서비스이다. 좌측 상단 지도 위에 있는 달력으로 원하는 시기의 수위 예측을 확인 할 수 있으며, 구역을 선택하면 우측 상단에 해당 구역의 정보가 나오게 된다. 해당 구역의 위험도와 점 검의 필요성 또한 알려주게 된다. 장기적 측면에서 예측 수위가 위험기준을 넘기게 된다면 예측된 해당의 일주일 전에 ‘점검필요’ 메 시지가 대시보드 화면 상에 출력된다. 단기적 측면에서 15분 단위로 예측된 수위비율을 출력하고 위험 기준을 넘길 시에 관련 당국에 경 보하게 된다."
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#분석-배경-및-필요성-3",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#분석-배경-및-필요성-3",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "1. 분석 배경 및 필요성",
    "text": "1. 분석 배경 및 필요성\n\n- 사고 사례\n\n\n- 연구의 필요성\n\n\n- 연구 관련 시스템 현황"
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#연구의-방향성-1",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#연구의-방향성-1",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "2. 연구의 방향성",
    "text": "2. 연구의 방향성"
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#데이터-설명-및-수집-1",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#데이터-설명-및-수집-1",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "1. 데이터 설명 및 수집",
    "text": "1. 데이터 설명 및 수집\n\n- 데이터 수집 방법\n\n\n- 데이터 설명\n\n\n- 데이터 시각화"
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#분석-방법-1",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#분석-방법-1",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "2. 분석 방법",
    "text": "2. 분석 방법\n\n- k-means clustering 모델을 활용한 구역 군집화\n\n\n- 상관관계 분석\n\n\n- 데이터 재구조화\n\n\n- 하수관로의 수위 비율 예측(LSTM, Transformer)"
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#서비스-활용-시-사용되는-대시보드-예시-1",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#서비스-활용-시-사용되는-대시보드-예시-1",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "3. 서비스 활용 시 사용되는 대시보드 예시",
    "text": "3. 서비스 활용 시 사용되는 대시보드 예시"
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#분석-배경-및-필요성-1",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#분석-배경-및-필요성-1",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "",
    "text": "매년 여름 주로 발생하는 피해는 단기 집중 호우와 홍수로 인한 피해일 것이다. 홍수로 인해서 침수 와 관련되어 맨홀 및 하수구와 관련된 사고 등 다양한 사고가 해마다 증가하고 있는 추세이다. 2022년 8월경 강남역 인근 맨홀에 남매가 맨홀 속으로 빨려들어 실종되어 결국 변사체로 발견하는 안타까운 사고가 발생하였다. 이 때 당시 강남역 일대에는 시간당 100mm 이상의 기록적인 폭우가 쏟아지면서 큰 인명과 재산 피해가 잇따라 발생했다.\n강남역 일대는 2010년부터 다섯 번이나 침수되었다. 침수나 정전 사고가 속출하면서 강남구 일대에 있는 주민들에게 엄청난 피해를 입혔다. 이는 처리 용량을 넘어선 기록적인 강수량이 침수 피해의 가 장 큰 요인이지만, 서울시의 부실한 대응 또한 무시할 수 없는 원인이라고 생각한다. 또한 경기 고양시는 2023년 1월 6일 기사에 따르면 하수도 막힘이나 역류, 맨홀 파손, 누수, 침하 등 사고가 지난 1년간 총 1천400여 건, 하루의 4번꼴로 신고가 접수되었다. 이들 사고 가운데 하수관 로에 기름때가 끼거나 음식물 쓰레기와 일회용 물티슈 등 이물질이 쌓여 생긴 막힘이 가장 많았다. 막힌 하수도를 신속하게 준설하지 않아 오·폐수가 가정집으로 흘러들어온 경우도 종종 있었다.\n\n\n\n위의 사례들뿐만 아니라 전 세계적으로도 비슷한 사고가 증가하는 추세이다. 지금까지 지속적으로 비슷한 사고가 발생해왔기에 하수구 관련 문제를 효율적으로 해결할 수 있는 시스템과 구체적인 방안 이 필요하다.\n2024년 기준 환경부 정책보고서의 내용에 따르면 이번 우리나라의 예산 중 하수관리정비(도시침수대 응)는 2023년 1,541억에서 2024년 3,275억원으로 예산이 증가하게 되었다. 또한 강남역, 광화문, 도 림천 저수시설 관리의 예산은 2023년 85억에서 2024년 262억원으로 증가하였다. 하지만 예산이 증 가하여도 비효율적인 점검과 관리를 하게 된다면 환경적 측면의 문제도 발생할뿐더러 시간적, 금전적 비용의 낭비가 극대화될 것이다. 또한 국민들은 자신의 안정성 보장받지 못하게 되고 이로 인한 반발 도 심해지게 될 것이다. 이와 같은 문제를 해결하기 위해 이번 연구에서 하수관로 수위 센서를 활용한 AI모델을 만들고 위/ 경도와 고/저도를 통한 군집 분석으로 구역을 나누어 예측 분석을 시행할 예정이다. 중장기적 관점으 로 보았을 때 효율적인 점검을 제안하고, 실시간 및 단기적 관점으로 살펴보았을 땐 위험구역 판별의 도움을 주는 시스템을 도입하여 두 가지 관점에서의 활용방안이 도입된다면 기존의 시스템보다 더 신 속하고 유용한 정보를 알려주게 될 것이다.\n\n\n\n2015년부터 서울시는 전국 최초로 하수관로 수위를 센서로 측정하여 모니터링하는 시스템을 12개 자치구 43개소에 구축한 데 이어 전 자치구에 48개소를 추가로 구축하였고 총 91개 하수관로 수위정 보를 실시간으로 모니터링하고 있다고 밝혔다. 현재 하수관로 모니터링 시스템은 서울시에서 관리하 고 있는 하수관거 총연장 1만487km 중 저지대 등 침수취약지역으로 하수 수위관리가 필요하다고 판 단한 지역을 위주로 설치됐다. 하수관로 맨홀에 수위계를 설치해 수위를 1분 간격으로 자동 측정해 서울시 통합안전상황실과 25개 자치구 재난안전대책본부로 전송되는 시스템이다. 기존엔 지하시설물 인 하수관로 특성상 육안확인이 어려워 집중호우 시 수위가 급격히 상승해 발생하는 문제점을 발견하 지 못했다면, 이제는 하수관로의 현재 수위가 얼마나 되는지 실시간으로 확인할 수 있게 되었다. 하 수도 수위가 관로높이의 60%이상 찰 때부터 해당지역 담당 공무원들에게 자동으로 문자가 발송되도 록 시스템을 구축하고, 하수관로 수위 변동 시 현장에 출동해 사전에 수해예방 조치를 취할 수 있도 록 했다. 수위비율이 80~90%를 넘어간다면 침수위험상황이라고 판단하여 자치구 재난안전대책본부에 서 해당지역 주민들에게 문자, 안내방송 등으로 즉시 상황을 전파해 신속히 대응하게 되는 시스템을 만들었다."
  },
  {
    "objectID": "posts/2024-1_강남구_공공데이터활용_공모전.html#연구의-방향성",
    "href": "posts/2024-1_강남구_공공데이터활용_공모전.html#연구의-방향성",
    "title": "하수관로 수위센서 활용 위험지역 탐지",
    "section": "",
    "text": "단기적/실시간적 관점 하루 15분 단위로 하수관로 수위를 예측하고, 군집 분석을 통해 수위가 급격히 상승하여 침수 가능 성이 높은 구역을 식별한다. 이를 통해 실시간으로 위험 구역을 파악하고, 관련 기관과 시민들에게 신속하게 경보를 제공한다. 수위가 급격히 상승하여 침수 위험이 높아진다고 예측되는 경우 관련 당국 및 관계자, 혹은 경찰이 나 소방관들에게 자동으로 경보를 발령하고, 즉각적인 대응 조치를 취할 수 있도록 한다. 이를 통해 시민들의 생명과 재산을 보호하고, 침수 피해를 최소화할 수 있게 된다.\n중장기적 관점 중장기적 관점에서 딥러닝 모델을 활용하여 과거의 기후 데이터와 하수관로 수위 데이터를 학습을 시킨다. 이를 통해 하수관로 수위의 시간적 변화를 예측하고, 향후 기간 동안의 수위를 추정함으로써 예측 모델을 통해 특정 분기 또는 기간 동안 침수 가능성이 높은 날짜와 시간대를 사전에 파악할 수 있게 된다. 중장기적 예측은 관련 기관 및 당국이 사전에 대응책을 마련하는데 도움을 줄 것이다. 또 한 하수구 및 관련 시설물의 점검 및 유지보수 작업을 미리 계획할 수 있게 됨으로써 사고 발생 가 능성을 사전에 예방할 수 있다.\n대시보드 제작 대시보드를 통해 하수관로 수위의 실시간 변화를 모니터링하고, 시각화된 데이터를 통해 관리자가 수위 상황을 쉽게 이해하고 대응할 수 있도록 한다. 이로써 관리자들은 신속하고 효과적인 의사 결정 을 내릴 수 있게 된다. 또한 대시보드를 통해 수위 예측 결과 및 위험 구역 정보를 관련 당국, 관리 자, 시민들에게 공유함으로써 투명하고 신속한 대응을 도모할 수 있게 될 것이다.\n데이터 기반 의사 결정 연구는 데이터를 기반으로 한 의사 결정을 지원하는 것을 목표로 한다. 수집된 데이터와 예측 모델 을 활용하여 하수관로 관리에 대한 효과적인 의사 결정을 내리는 것이 중요하다. 데이터 기반의 접근 은 관리자들이 효과적인 대응 및 관리를 할 수 있도록 도와줄 것이며, 이를 통해 하수관로 관리의 효 율성을 높이고 문제 해결에 보다 신속하게 대응할 수 있다.\n협력과 정보 공유 연구는 관련 기관 및 당국과의 협력을 강화하고 연구 결과를 공유하는 것을 목표로 한다. 협력과 정 보 공유를 통해 연구 결과를 보다 효과적으로 활용할 수 있으며, 이를 통해 지역 사회의 안전과 안정 성을 증진시킬 수 있다. 또한, 협력과 정보 공유를 통해 관련 기관과의 소통을 원활하게 하고, 문제 해결에 보다 효과적으로 대응할 수 있다."
  }
]